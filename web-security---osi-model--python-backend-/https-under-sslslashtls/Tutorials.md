## Symmetric key encryption

The goal of the TLS handshake procedure is to exchange a master-key between the client and the server. Once a master-key was securely agreed, the client and the server can transfer messages in an encrypted manner, and both sides can verify data integrity. 

In this exercise we assume that both sides have already exchanged the master-key, and see how encryption and data integrity is done using `openssl` cli. 

Let's assume that the master-key that was agreed by the client and the server is `12345678`. Only the client and the server know that key, it's a secret.

In the Terminal panel, you are given a file called `BankTransferTransaction` containing a JSON message representing a bank transfer from Bob to Alice. 

We, as clients, want to securely transfer the message to the bank server. 

Encrypt the message by:
```
openssl enc -e -aes-256-cbc -pbkdf2 -k "12345678" -in BankTransferTransaction -out BankTransferTransaction_Encrypted
```

Can you see how do we use the master-key in the encryption command? 

`cat BankTransferTransaction_Encrypted` file to see the encrypted content, it should be Gibberish to you and to every other person who does not have the master-key.  

Try to encrypt the message using a master-key different than `12345678`. You will see that different encrypted content is generated by different master-keys. 

Now let's say we are the server, who received this message and wants to decrypt it. 

Decrypt the message by: 
```
openssl enc -d -aes-256-cbc -pbkdf2 -k "12345678" -in BankTransferTransaction_Encrypted
```

Can you see the original message? Try to decrypt using different master-key and confirm that the message was not decrypted successfully. 

This is the essence of symmetric encryption, the same key which was used to encrypt, is used to decrypt. By this means it is a **symmetric** process.

So we have privacy! What about data integrity? Try to change the encrypted message by appending the following text to `BankTransferTransaction_Encrypted`:

```
echo "some malicious change" >> BankTransferTransaction_Encrypted
```

Verify that the encrypted message was altered by
`cat BankTransferTransaction_Encrypted`. 

Now try to decrypt again, expect openssl to output "bad decrypt" message, which indicates that the original encrypted message was altered by someone.


|||info
The `openssl enc` command implements both **encryption** and **data integrity** functionality.


For more information on the `openssl enc` command, read Openssl's [man page](https://www.openssl.org/docs/man1.0.2/man1/openssl-enc.html). 

|||


## Asymmetric key encryption

In the previous section we've seen how client and server can communicate using a shared master-key. But keep in mind that this key must to be agreed by both sides first. We can do it by utilizing asymmetric encryption. 

In this exercise we generate a public-private key pair and encrypt messages. We will use `openssl` again.

#### Generate private key

Generate a 1024 bit length private key. Choose an easy pass phrase for your key so you can remember it later, something like 1234. 

```
openssl genrsa -aes256 -out private.key 1024
```

Confirm your private key by `cat private.key`.

#### Generate public key

Using the generated private key, generate a public key pair:

```
openssl rsa -in private.key -pubout -out public.key
```

Confirm your public key by `cat public.key`.

#### Encrypt a message

Now imagine that you are a client who wants to transfer a master-key to the server so you can communicate securely as we did in the previous exercise. 

You have the public key of the server under `public.key` in your file system (the server sent it to you earlier...). 

You are given a file called `MasterKeyForTheServer` which contains the above used master-key (`1234568`). Encrypt this file by:
```
openssl rsautl -encrypt -pubin -inkey public.key -in MasterKeyForTheServer -out MasterKeyForTheServer_Encrypted
```

Since this file was encrypted by the server's public key, it can be securely sent over the internet. The only one who can decrypt it is the server, which owns the correspond private key. 

Let's say the file was sent to the server and it decrypts it by:

```
openssl rsautl -decrypt -inkey private.key -in MasterKeyForTheServer_Encrypted
```

Can you see the decrypted master key? 


## Self-signed certificate 

In this exercise you will generate an SSL certificate. In real life, a trusted authority (like Amazon) should sign on your certificates, which gives them validity. But as we are learning, you will generate a certificate and sign it yourself (a.k.a. self-signed certificate). 

We will be using, right guess, `openssl`:

```
openssl req -x509 -newkey rsa:1024 -keyout key.pem -out cert.pem -sha256 -days 365
```

The program will ask you some identifiable information: who are you? what is the organization you are belonging to? your country, your mail etc... All these details, including a public key, will be encoded into a file called `cert.pem`. Note that this certificate has an expiration time of 365 days. 

`cat cert.pem` to see how a certificate may look like. In our simplified TLS handshake model, the server's certificate is the first thing that was sent to the client.  

## Explore Codio's certificate

Click on the lock icon next to `codio.com` url in this browser. Explor the certificate details and answers the following questions:

1. Who is the Certificate Authority from which codio.com issued their certificate? 
2. What is the certificate expiration date? 
3. What is the public key algorithm used to generate the public key? how many bits? 



<details>
  <summary>
     Solution
  </summary>
    
1. Amazon
2. Sun, 19 Feb 2023 23:59:59 GMT
3. RSA 2048

</details>